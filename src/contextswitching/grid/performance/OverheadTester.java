/**
 * Licensed under the MIT license: 
 * 
 * http://www.opensource.org/licenses/mit-license.php 
 */
package contextswitching.grid.performance;

import java.util.List;
import org.jppf.JPPFException;
import org.jppf.client.JPPFClient;
import org.jppf.client.JPPFJob;
import org.jppf.server.protocol.JPPFTask;

/**
 * This class represents an example of a simple JPPF grid client
 * with clocking job submission 
 * 
 * This example submits a job with dummy tasks that take 
 * a specific time to me executed
 * 
 * This aims to provide an easy way to analyse the overhead 
 * generated by the usage of the grid system
 * 
 * 
 * @author Davide Nunes
 */
public class OverheadTester {
    
    private static JPPFClient jppfClient;

    
    /**
     * Run an experiment with dummy tasks to evaluate the
     * rough overhead created by using the grid
     * 
     * 
     * //TODO create an experiment where the number of 
     * tasks grows and we observe the performance gains
     * 
     * //TODO observe that for only one task we can measure the 
     * overhead produced by the grid
     * 
     * @param args 
     */
    public static void main(String[] args) throws JPPFException, Exception {
        //init the Grid Client
        jppfClient =  new JPPFClient();
        
        int numTasks = 1;
        int taskDuration = 1000;
        JPPFJob dummy = createJob(100, 0);
        executeBlockingJob(dummy);//this job is just submitted to 
        //distribute the classes to the grid nodes
        
        System.out.println("Creating Dummy Job");
        JPPFJob job = createJob(numTasks, taskDuration);
        
        long beforeSubmission = System.currentTimeMillis();
        List<JPPFTask> results = executeBlockingJob(job);      
        long afterSubmission = System.currentTimeMillis();
        
        int idealTime = numTasks*taskDuration;
        long actualDuration = (afterSubmission - beforeSubmission) ;
        
        System.out.println("Ideal Task Execution Time: "+idealTime);
        System.out.println("Actual Task ExecutionTime: "+actualDuration);
        jppfClient.close();
    }

    
    /**
     * Creates a Grid job with numTasks tasks.
     * Each task takes taskDuration to execute.
     * 
     * @param numTasks the number of tasks contained in the job
     * @param taskDuration the duration of the task execution
     * 
     * @return job JPPFJob the newly created job
     * @throws JPPFException 
     */
    private static JPPFJob createJob(int numTasks, int taskDuration)
            throws JPPFException {
        // create a JPPF job
        JPPFJob job = new JPPFJob();

        // add a task to the job.
        for (int i = 0; i < numTasks; i++) {
            job.addTask(new DummyTask(taskDuration));
        }
        return job;
    }
    
    
    /**
     * This method uses the grid client object to submit a given job
     * The job is set to blocking, which means that the program stops and waits 
     * for the results from the grid before continuing its execution.
     * 
     * @param job JPPFJob the job to be submitted to the grid
     * 
     * @return result list - the task results returned from the grid
     *
     * @throws Exception 
     */
    private static List<JPPFTask> executeBlockingJob(JPPFJob job) throws Exception {
        // set the job in blocking mode.
        job.setBlocking(true);

        // Submit the job and wait until the results are returned.
        // The results are returned as a list of JPPFTask instances,
        // in the same order as the one in which the tasks where initially added the job.
        System.out.println("Job submited wating for results...");

        List<JPPFTask> results = jppfClient.submit(job); //simulation results
        
        //you can access one task results by invoking the method getResult()
        
        return results;
    }
}
